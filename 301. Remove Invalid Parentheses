public class Solution {
    public List<String> removeInvalidParentheses(String s) {
        List<String> list = new ArrayList<>();
        Queue<String> queue = new LinkedList<>();
        Set<String> set = new HashSet<>();
        queue.offer(s);
        set.add(s);
        boolean found = false;
        while(!queue.isEmpty()){
            s = queue.poll();
            if(isValid(s)){
                list.add(s);
                found = true; // once we find a valid result, we don't need to remove any other parentheses any more. So we keep continue
            }
            if(found){continue;}
            for(int i = 0; i < s.length(); i++){
                if(s.charAt(i) != '(' && s.charAt(i) != ')')continue;
                String next = s.substring(0,i) + s.substring(i+1);
                if(!set.contains(next)){
                    queue.offer(next);
                    set.add(next);
                }
            }
        }
        return list;
    }
    public boolean isValid(String s){
        int count = 0;
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == '('){
                count++;
            }
            else if(s.charAt(i) == ')'){
                if(count == 0) return false;
                count--;
            }
        }
        return count == 0;
    }
}

On the first level, there's only one string which is the input string s, let's say the length of it is n, to check whether it's valid, we need O(n) time. On the second level, we remove one ( or ) from the first level, so there are C(n, n-1) new strings, each of them has n-1 characters, and for each string, we need to check whether it's valid or not, thus the total time complexity on this level is (n-1) x C(n, n-1). Come to the third level, total time complexity is (n-2) x C(n, n-2), so on and so forth...

Finally we have this formula:

T(n) = n x C(n, n) + (n-1) x C(n, n-1) + ... + 1 x C(n, 1) = n x 2^(n-1).
