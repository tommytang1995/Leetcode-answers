public class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int sum = 0, from = 0, win = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            while (sum >= s) {
                win = Math.min(win, i - from + 1);
                sum -= nums[from++];
            }
        }
        return (win == Integer.MAX_VALUE) ? 0 : win;
    }
}

public class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int sum = 0;
        int from = 0;
        int window = nums.length + 1;
        int i = 0;
        while(i < nums.length){
            while(i < nums.length && sum < s){
                sum += nums[i++];
            }
            while(sum >= s){
                window = Math.min(window, i-from);
                sum -= nums[from++];
            }
        }
        return window == nums.length + 1 ? 0 : window;
    }
}
Time: o(2n)/o(n)
Space: o(1)

public class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int sum = 0;
        int from = 0;
        int window = nums.length + 1;
        int[] sums = new int[nums.length];   //把每个元素之前的所有元素（包括此元素）之和存起来
        for(int i = 0; i < nums.length; i++){
            if(i == 0){
                sums[i] = 0 + nums[i];
            }
            else{
                sums[i] = sums[i-1] + nums[i];
            }
        }
        for(int i = 0; i < nums.length; i++){  //找到这个window的end，以此判断window的长度
            from = i;  //从每个元素开始找
            int to = nums.length-1;   //直到最后一个元素
            int temp = (from == 0 ? 0 : sums[from - 1]);  //减去该window以前的和，从而判断与s的大小关系
            while(from <= to){
                int mid = from + (to - from) / 2;
                if(sums[mid] - temp >= s){  //若大于或等于，试着向左移动end
                    to = mid - 1;
                }
                else{  //若小于，向右移动start
                    from = mid + 1;
                }
            }
            if(from == nums.length)break;  //超出界限，返回，从i开始说明不存在此种window
            window = Math.min(window, from - i + 1);
        }
        return window == nums.length + 1 ? 0 : window;
    }
}
Time: o(nlogn)
Space: o(n)
